1. Настраиваем асинхронную репликацию.
* настроена репликация в папке repl-compose композ - поднимается через build.sh

2. Выбираем 2 любых запроса на чтения (в идеале самых частых и тяжелых по логике работы сайта) и переносим их на чтение со слейва.
* пользуемся тем же запросом что для тестирования индекса(открытая ручка для поиска записей по имени и фамилии)
 http://0.0.0.0:3000/account/search_user?firstname=Bobby&secondname=Chase
(поставил 1 запрос - все эксперименты на локальной машине проводились)
3. Делаем нагрузочный тест по странице, которую перевели на слейв до и после репликации. Замеряем нагрузку мастера (CPU, la, disc usage, memory usage).
* переключаем приложение на слейв
* нагрузку на чтение через  wrk -t1 -c1 -d1000s --timeout 10  --latency 'http://0.0.0.0:3000/account/search_user?firstname=Bobby&secondname=Chase'
* снимаем нагрузку на контейнере мастера (docker stats mysql_master)
* статы до включения нагрузки
CONTAINER ID   NAME           CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O        PIDS
135cc1a54994   mysql_master   0.09%     364.3MiB / 1.943GiB   18.31%    87.6MB / 96.2MB   139MB / 36.5MB   31
* статы после включения нагрузки (приложение подключено к мастеру)
CONTAINER ID   NAME           CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O        PIDS
135cc1a54994   mysql_master   104.95%   373.1MiB / 1.943GiB   18.75%    87.6MB / 96.2MB   139MB / 36.5MB   31
* статы после включения нагрузки (приложение подключено к слейву)
CONTAINER ID   NAME           CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O        PIDS
135cc1a54994   mysql_master   0.08%     351.2MiB / 1.943GiB   17.65%    87.6MB / 96.2MB   139MB / 36.5MB   31


4. ОПЦИОНАЛЬНО: в качестве конфига, который хранит IP реплики сделать массив для легкого добавления реплики. Это не самый правильный способ балансирования нагрузки. Поэтому опционально.
5. Настроить 2 слейва и 1 мастер.
6. Включить row-based репликацию.
7. Включить GTID.
8. Настроить полусинхронную репликацию.
9. Создать нагрузку на запись в любую тестовую таблицу. На стороне, которой нагружаем считать, сколько строк мы успешно записали.
10. С помощью kill -9 убиваем мастер MySQL.
11. Заканчиваем нагрузку на запись.
12. Выбираем самый свежий слейв. Промоутим его до мастера. Переключаем на него второй слейв.
13.vПроверяем, есть ли потери транзакций.