1. Настраиваем асинхронную репликацию.
* настроена репликация в папке repl-compose композ - поднимается через build.sh
поднимаем композ
исполняем команды
на мастере
-- first
GRANT REPLICATION SLAVE ON *.* TO "mydb_slave_user"@"%" IDENTIFIED BY "mydb_slave_pwd"; FLUSH PRIVILEGES;
-- second
SHOW MASTER STATUS;
на слейве:
CHANGE MASTER TO MASTER_HOST ='172.27.0.2',MASTER_USER ='mydb_slave_user',MASTER_PASSWORD ='mydb_slave_pwd',MASTER_LOG_FILE ='mysql-bin.000003',MASTER_LOG_POS =638;
START SLAVE;

2. Выбираем 2 любых запроса на чтения (в идеале самых частых и тяжелых по логике работы сайта) и переносим их на чтение со слейва.
* пользуемся тем же запросом что для тестирования индекса(открытая ручка для поиска записей по имени и фамилии)
 http://0.0.0.0:3000/account/search_user?firstname=Bobby&secondname=Chase
(поставил 1 запрос - все эксперименты на локальной машине проводились)
3. Делаем нагрузочный тест по странице, которую перевели на слейв до и после репликации. Замеряем нагрузку мастера (CPU, la, disc usage, memory usage).
* переключаем приложение на слейв
* нагрузку на чтение через  wrk -t1 -c1 -d1000s --timeout 10  --latency 'http://0.0.0.0:3000/account/search_user?firstname=Bobby&secondname=Chase'
* снимаем нагрузку на контейнере мастера (docker stats mysql_master)
* статы до включения нагрузки
CONTAINER ID   NAME           CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O        PIDS
135cc1a54994   mysql_master   0.09%     364.3MiB / 1.943GiB   18.31%    87.6MB / 96.2MB   139MB / 36.5MB   31
* статы после включения нагрузки (приложение подключено к мастеру)
CONTAINER ID   NAME           CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O        PIDS
135cc1a54994   mysql_master   104.95%   373.1MiB / 1.943GiB   18.75%    87.6MB / 96.2MB   139MB / 36.5MB   31
* статы после включения нагрузки (приложение подключено к слейву)
CONTAINER ID   NAME           CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O        PIDS
135cc1a54994   mysql_master   0.08%     351.2MiB / 1.943GiB   17.65%    87.6MB / 96.2MB   139MB / 36.5MB   31


4. ОПЦИОНАЛЬНО: в качестве конфига, который хранит IP реплики сделать массив для легкого добавления реплики. Это не самый правильный способ балансирования нагрузки. Поэтому опционально.
5. Настроить 2 слейва и 1 мастер.
+ 1 слейв в композ
6. Включить row-based репликацию.
binlog_format = ROW
7. Включить GTID.
в конфигах
gtid_mode=ON
enforce_gtid_consistency=ON
8. Настроить полусинхронную репликацию.
на слейвах
CHANGE MASTER TO MASTER_HOST ='172.28.0.2',MASTER_USER ='mydb_slave_user',MASTER_PASSWORD ='mydb_slave_pwd',MASTER_LOG_FILE ='mysql-bin.000003',MASTER_LOG_POS =678;
SET @rpl_semi_sync_slave = 1;
START SLAVE;
9. Создать нагрузку на запись в любую тестовую таблицу. На стороне, которой нагружаем считать, сколько строк мы успешно записали.
создаем на мастере таблицу
create table mydb.test
(
    id bigint null
);
тестовое приложение
cmd/transaction/main.go
пишем строки - в транзакции по 100 записей
10. С помощью kill -9 убиваем мастер MySQL.
после убийства мастера последний id от приложения last id 27670
последний закомиченный 27600
проверяем оба слейва у каждого последняя строка 27600
11. Заканчиваем нагрузку на запись.
12. Выбираем самый свежий слейв. Промоутим его до мастера. Переключаем на него второй слейв.
13.vПроверяем, есть ли потери транзакций.

Промоутим слейв_2 до мастера
flush tables; flush logs;
stop slave;
set global read_only=OFF;
GRANT REPLICATION SLAVE ON *.* TO "mydb_slave_user"@"%" IDENTIFIED BY "mydb_slave_pwd";

Переключаем слейв_1
show slave status;
flush tables; flush logs;
stop slave;
CHANGE MASTER TO MASTER_HOST='172.28.0.4',
    MASTER_USER='mydb_slave_user',
    MASTER_PASSWORD='mydb_slave_pwd',
    MASTER_LOG_FILE='mysql-bin.000004',
    MASTER_LOG_POS=473148;
START SLAVE;

Запускаем приложение - пишем в новый мастер - читаем на слейве(потерь нету).